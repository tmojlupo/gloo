// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: github.com/solo-io/gloo/projects/gloo/api/v1/connection.proto

package v1

import (
	bytes "bytes"
	fmt "fmt"
	math "math"
	time "time"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	_ "github.com/solo-io/protoc-gen-ext/extproto"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Action to take when Envoy receives client request with header names containing underscore
// characters.
// Underscore character is allowed in header names by the RFC-7230 and this behavior is implemented
// as a security measure due to systems that treat '_' and '-' as interchangeable. Envoy by default allows client request headers with underscore
// characters.
type ConnectionConfig_HttpProtocolOptions_HeadersWithUnderscoresAction int32

const (
	// Allow headers with underscores. This is the default behavior.
	ConnectionConfig_HttpProtocolOptions_ALLOW ConnectionConfig_HttpProtocolOptions_HeadersWithUnderscoresAction = 0
	// Reject client request. HTTP/1 requests are rejected with the 400 status. HTTP/2 requests
	// end with the stream reset. The "httpN.requests_rejected_with_underscores_in_headers" counter
	// is incremented for each rejected request.
	ConnectionConfig_HttpProtocolOptions_REJECT_REQUEST ConnectionConfig_HttpProtocolOptions_HeadersWithUnderscoresAction = 1
	// Drop the header with name containing underscores. The header is dropped before the filter chain is
	// invoked and as such filters will not see dropped headers. The
	// "httpN.dropped_headers_with_underscores" is incremented for each dropped header.
	ConnectionConfig_HttpProtocolOptions_DROP_HEADER ConnectionConfig_HttpProtocolOptions_HeadersWithUnderscoresAction = 2
)

var ConnectionConfig_HttpProtocolOptions_HeadersWithUnderscoresAction_name = map[int32]string{
	0: "ALLOW",
	1: "REJECT_REQUEST",
	2: "DROP_HEADER",
}

var ConnectionConfig_HttpProtocolOptions_HeadersWithUnderscoresAction_value = map[string]int32{
	"ALLOW":          0,
	"REJECT_REQUEST": 1,
	"DROP_HEADER":    2,
}

func (x ConnectionConfig_HttpProtocolOptions_HeadersWithUnderscoresAction) String() string {
	return proto.EnumName(ConnectionConfig_HttpProtocolOptions_HeadersWithUnderscoresAction_name, int32(x))
}

func (ConnectionConfig_HttpProtocolOptions_HeadersWithUnderscoresAction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_56610fe13cf10c84, []int{0, 1, 0}
}

// Fine tune the settings for connections to an upstream
type ConnectionConfig struct {
	// Maximum requests for a single upstream connection (unspecified or zero = no limit)
	MaxRequestsPerConnection uint32 `protobuf:"varint,1,opt,name=max_requests_per_connection,json=maxRequestsPerConnection,proto3" json:"max_requests_per_connection,omitempty"`
	// The timeout for new network connections to hosts in the cluster
	ConnectTimeout *time.Duration `protobuf:"bytes,2,opt,name=connect_timeout,json=connectTimeout,proto3,stdduration" json:"connect_timeout,omitempty"`
	// Configure OS-level tcp keepalive checks
	TcpKeepalive *ConnectionConfig_TcpKeepAlive `protobuf:"bytes,3,opt,name=tcp_keepalive,json=tcpKeepalive,proto3" json:"tcp_keepalive,omitempty"`
	// Soft limit on size of the clusterâ€™s connections read and write buffers. If unspecified, an implementation defined default is applied (1MiB).
	// For more info, see the [envoy docs](https://www.envoyproxy.io/docs/envoy/v1.14.1/api-v2/api/v2/cluster.proto#cluster)
	PerConnectionBufferLimitBytes *types.UInt32Value `protobuf:"bytes,4,opt,name=per_connection_buffer_limit_bytes,json=perConnectionBufferLimitBytes,proto3" json:"per_connection_buffer_limit_bytes,omitempty"`
	// Additional options when handling HTTP requests upstream. These options will be applicable to
	// both HTTP1 and HTTP2 requests.
	CommonHttpProtocolOptions *ConnectionConfig_HttpProtocolOptions `protobuf:"bytes,5,opt,name=common_http_protocol_options,json=commonHttpProtocolOptions,proto3" json:"common_http_protocol_options,omitempty"`
	XXX_NoUnkeyedLiteral      struct{}                              `json:"-"`
	XXX_unrecognized          []byte                                `json:"-"`
	XXX_sizecache             int32                                 `json:"-"`
}

func (m *ConnectionConfig) Reset()         { *m = ConnectionConfig{} }
func (m *ConnectionConfig) String() string { return proto.CompactTextString(m) }
func (*ConnectionConfig) ProtoMessage()    {}
func (*ConnectionConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_56610fe13cf10c84, []int{0}
}
func (m *ConnectionConfig) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConnectionConfig.Unmarshal(m, b)
}
func (m *ConnectionConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConnectionConfig.Marshal(b, m, deterministic)
}
func (m *ConnectionConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectionConfig.Merge(m, src)
}
func (m *ConnectionConfig) XXX_Size() int {
	return xxx_messageInfo_ConnectionConfig.Size(m)
}
func (m *ConnectionConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectionConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectionConfig proto.InternalMessageInfo

func (m *ConnectionConfig) GetMaxRequestsPerConnection() uint32 {
	if m != nil {
		return m.MaxRequestsPerConnection
	}
	return 0
}

func (m *ConnectionConfig) GetConnectTimeout() *time.Duration {
	if m != nil {
		return m.ConnectTimeout
	}
	return nil
}

func (m *ConnectionConfig) GetTcpKeepalive() *ConnectionConfig_TcpKeepAlive {
	if m != nil {
		return m.TcpKeepalive
	}
	return nil
}

func (m *ConnectionConfig) GetPerConnectionBufferLimitBytes() *types.UInt32Value {
	if m != nil {
		return m.PerConnectionBufferLimitBytes
	}
	return nil
}

func (m *ConnectionConfig) GetCommonHttpProtocolOptions() *ConnectionConfig_HttpProtocolOptions {
	if m != nil {
		return m.CommonHttpProtocolOptions
	}
	return nil
}

// If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
// see more info here: https://www.envoyproxy.io/docs/envoy/latest/api-v2/api/v2/core/address.proto#envoy-api-msg-core-tcpkeepalive
type ConnectionConfig_TcpKeepAlive struct {
	// Maximum number of keepalive probes to send without response before deciding the connection is dead.
	KeepaliveProbes uint32 `protobuf:"varint,1,opt,name=keepalive_probes,json=keepaliveProbes,proto3" json:"keepalive_probes,omitempty"`
	// The number of seconds a connection needs to be idle before keep-alive probes start being sent. This is rounded up to the second.
	KeepaliveTime *time.Duration `protobuf:"bytes,2,opt,name=keepalive_time,json=keepaliveTime,proto3,stdduration" json:"keepalive_time,omitempty"`
	// The number of seconds between keep-alive probes. This is rounded up to the second.
	KeepaliveInterval    *time.Duration `protobuf:"bytes,3,opt,name=keepalive_interval,json=keepaliveInterval,proto3,stdduration" json:"keepalive_interval,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ConnectionConfig_TcpKeepAlive) Reset()         { *m = ConnectionConfig_TcpKeepAlive{} }
func (m *ConnectionConfig_TcpKeepAlive) String() string { return proto.CompactTextString(m) }
func (*ConnectionConfig_TcpKeepAlive) ProtoMessage()    {}
func (*ConnectionConfig_TcpKeepAlive) Descriptor() ([]byte, []int) {
	return fileDescriptor_56610fe13cf10c84, []int{0, 0}
}
func (m *ConnectionConfig_TcpKeepAlive) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConnectionConfig_TcpKeepAlive.Unmarshal(m, b)
}
func (m *ConnectionConfig_TcpKeepAlive) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConnectionConfig_TcpKeepAlive.Marshal(b, m, deterministic)
}
func (m *ConnectionConfig_TcpKeepAlive) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectionConfig_TcpKeepAlive.Merge(m, src)
}
func (m *ConnectionConfig_TcpKeepAlive) XXX_Size() int {
	return xxx_messageInfo_ConnectionConfig_TcpKeepAlive.Size(m)
}
func (m *ConnectionConfig_TcpKeepAlive) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectionConfig_TcpKeepAlive.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectionConfig_TcpKeepAlive proto.InternalMessageInfo

func (m *ConnectionConfig_TcpKeepAlive) GetKeepaliveProbes() uint32 {
	if m != nil {
		return m.KeepaliveProbes
	}
	return 0
}

func (m *ConnectionConfig_TcpKeepAlive) GetKeepaliveTime() *time.Duration {
	if m != nil {
		return m.KeepaliveTime
	}
	return nil
}

func (m *ConnectionConfig_TcpKeepAlive) GetKeepaliveInterval() *time.Duration {
	if m != nil {
		return m.KeepaliveInterval
	}
	return nil
}

type ConnectionConfig_HttpProtocolOptions struct {
	// The idle timeout for connections. The idle timeout is defined as the
	// period in which there are no active requests. When the
	// idle timeout is reached the connection will be closed. If the connection is an HTTP/2
	// downstream connection a drain sequence will occur prior to closing the connection, see
	// :ref:`drain_timeout
	// <envoy_api_field_extensions.filters.network.http_connection_manager.v3.HttpConnectionManager.drain_timeout>`.
	// Note that request based timeouts mean that HTTP/2 PINGs will not keep the connection alive.
	// If not specified, this defaults to 1 hour. To disable idle timeouts explicitly set this to 0.
	//
	// .. warning::
	//   Disabling this timeout has a highly likelihood of yielding connection leaks due to lost TCP
	//   FIN packets, etc.
	IdleTimeout *time.Duration `protobuf:"bytes,1,opt,name=idle_timeout,json=idleTimeout,proto3,stdduration" json:"idle_timeout,omitempty"`
	// The maximum number of headers. If unconfigured, the default
	// maximum number of request headers allowed is 100. Requests that exceed this limit will receive
	// a 431 response for HTTP/1.x and cause a stream reset for HTTP/2.
	MaxHeadersCount uint32 `protobuf:"varint,2,opt,name=max_headers_count,json=maxHeadersCount,proto3" json:"max_headers_count,omitempty"`
	// Total duration to keep alive an HTTP request/response stream. If the time limit is reached the stream will be
	// reset independent of any other timeouts. If not specified, this value is not set.
	MaxStreamDuration *time.Duration `protobuf:"bytes,3,opt,name=max_stream_duration,json=maxStreamDuration,proto3,stdduration" json:"max_stream_duration,omitempty"`
	// Action to take when a client request with a header name containing underscore characters is received.
	// If this setting is not specified, the value defaults to ALLOW.
	// Note: upstream responses are not affected by this setting.
	HeadersWithUnderscoresAction ConnectionConfig_HttpProtocolOptions_HeadersWithUnderscoresAction `protobuf:"varint,4,opt,name=headers_with_underscores_action,json=headersWithUnderscoresAction,proto3,enum=gloo.solo.io.ConnectionConfig_HttpProtocolOptions_HeadersWithUnderscoresAction" json:"headers_with_underscores_action,omitempty"`
	XXX_NoUnkeyedLiteral         struct{}                                                          `json:"-"`
	XXX_unrecognized             []byte                                                            `json:"-"`
	XXX_sizecache                int32                                                             `json:"-"`
}

func (m *ConnectionConfig_HttpProtocolOptions) Reset()         { *m = ConnectionConfig_HttpProtocolOptions{} }
func (m *ConnectionConfig_HttpProtocolOptions) String() string { return proto.CompactTextString(m) }
func (*ConnectionConfig_HttpProtocolOptions) ProtoMessage()    {}
func (*ConnectionConfig_HttpProtocolOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_56610fe13cf10c84, []int{0, 1}
}
func (m *ConnectionConfig_HttpProtocolOptions) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ConnectionConfig_HttpProtocolOptions.Unmarshal(m, b)
}
func (m *ConnectionConfig_HttpProtocolOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ConnectionConfig_HttpProtocolOptions.Marshal(b, m, deterministic)
}
func (m *ConnectionConfig_HttpProtocolOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConnectionConfig_HttpProtocolOptions.Merge(m, src)
}
func (m *ConnectionConfig_HttpProtocolOptions) XXX_Size() int {
	return xxx_messageInfo_ConnectionConfig_HttpProtocolOptions.Size(m)
}
func (m *ConnectionConfig_HttpProtocolOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_ConnectionConfig_HttpProtocolOptions.DiscardUnknown(m)
}

var xxx_messageInfo_ConnectionConfig_HttpProtocolOptions proto.InternalMessageInfo

func (m *ConnectionConfig_HttpProtocolOptions) GetIdleTimeout() *time.Duration {
	if m != nil {
		return m.IdleTimeout
	}
	return nil
}

func (m *ConnectionConfig_HttpProtocolOptions) GetMaxHeadersCount() uint32 {
	if m != nil {
		return m.MaxHeadersCount
	}
	return 0
}

func (m *ConnectionConfig_HttpProtocolOptions) GetMaxStreamDuration() *time.Duration {
	if m != nil {
		return m.MaxStreamDuration
	}
	return nil
}

func (m *ConnectionConfig_HttpProtocolOptions) GetHeadersWithUnderscoresAction() ConnectionConfig_HttpProtocolOptions_HeadersWithUnderscoresAction {
	if m != nil {
		return m.HeadersWithUnderscoresAction
	}
	return ConnectionConfig_HttpProtocolOptions_ALLOW
}

func init() {
	proto.RegisterEnum("gloo.solo.io.ConnectionConfig_HttpProtocolOptions_HeadersWithUnderscoresAction", ConnectionConfig_HttpProtocolOptions_HeadersWithUnderscoresAction_name, ConnectionConfig_HttpProtocolOptions_HeadersWithUnderscoresAction_value)
	proto.RegisterType((*ConnectionConfig)(nil), "gloo.solo.io.ConnectionConfig")
	proto.RegisterType((*ConnectionConfig_TcpKeepAlive)(nil), "gloo.solo.io.ConnectionConfig.TcpKeepAlive")
	proto.RegisterType((*ConnectionConfig_HttpProtocolOptions)(nil), "gloo.solo.io.ConnectionConfig.HttpProtocolOptions")
}

func init() {
	proto.RegisterFile("github.com/solo-io/gloo/projects/gloo/api/v1/connection.proto", fileDescriptor_56610fe13cf10c84)
}

var fileDescriptor_56610fe13cf10c84 = []byte{
	// 642 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x54, 0xcd, 0x72, 0xd3, 0x30,
	0x10, 0xc6, 0xfd, 0x61, 0x40, 0xcd, 0x5f, 0x55, 0x0e, 0x69, 0x08, 0x6d, 0xe9, 0xa9, 0xc0, 0x60,
	0x43, 0x7a, 0x63, 0xa6, 0x87, 0x24, 0x0d, 0x93, 0x42, 0xa7, 0x09, 0x6e, 0x4a, 0x67, 0xb8, 0x68,
	0x14, 0x77, 0xe3, 0x88, 0xda, 0x96, 0x90, 0xe5, 0x36, 0xbc, 0x08, 0xc3, 0x23, 0xf0, 0x08, 0xdc,
	0x78, 0x06, 0x9e, 0x00, 0x86, 0x77, 0xe0, 0xce, 0xc8, 0x72, 0x92, 0x42, 0x3b, 0x6d, 0xb8, 0x59,
	0xbb, 0xfb, 0x7d, 0xfb, 0x7d, 0xda, 0xb5, 0xd0, 0x8e, 0xcf, 0xd4, 0x30, 0xe9, 0xdb, 0x1e, 0x0f,
	0x9d, 0x98, 0x07, 0xfc, 0x29, 0xe3, 0x8e, 0x1f, 0x70, 0xee, 0x08, 0xc9, 0xdf, 0x83, 0xa7, 0x62,
	0x73, 0xa2, 0x82, 0x39, 0x67, 0xcf, 0x1d, 0x8f, 0x47, 0x11, 0x78, 0x8a, 0xf1, 0xc8, 0x16, 0x92,
	0x2b, 0x8e, 0x73, 0x3a, 0x6b, 0x6b, 0xa0, 0xcd, 0x78, 0xe5, 0x9e, 0xcf, 0x7d, 0x9e, 0x26, 0x1c,
	0xfd, 0x65, 0x6a, 0x2a, 0x6b, 0x3e, 0xe7, 0x7e, 0x00, 0x4e, 0x7a, 0xea, 0x27, 0x03, 0xe7, 0x24,
	0x91, 0x74, 0xca, 0x71, 0x39, 0x7f, 0x2e, 0xa9, 0x10, 0x20, 0xe3, 0x2c, 0x8f, 0x61, 0xa4, 0x0c,
	0x29, 0x8c, 0x94, 0x89, 0x6d, 0xfe, 0xbc, 0x83, 0x4a, 0xcd, 0x89, 0x98, 0x26, 0x8f, 0x06, 0xcc,
	0xc7, 0x3b, 0xe8, 0x7e, 0x48, 0x47, 0x44, 0xc2, 0x87, 0x04, 0x62, 0x15, 0x13, 0x01, 0x92, 0x4c,
	0x15, 0x97, 0xad, 0x0d, 0x6b, 0x2b, 0xef, 0x96, 0x43, 0x3a, 0x72, 0xb3, 0x8a, 0x2e, 0xc8, 0x29,
	0x09, 0x6e, 0xa3, 0x62, 0x56, 0x4d, 0x14, 0x0b, 0x81, 0x27, 0xaa, 0x3c, 0xb7, 0x61, 0x6d, 0x2d,
	0xd5, 0x56, 0x6d, 0xa3, 0xd0, 0x1e, 0x2b, 0xb4, 0x77, 0x33, 0x07, 0x8d, 0x85, 0xcf, 0x3f, 0xd6,
	0x2d, 0xb7, 0x90, 0xe1, 0x7a, 0x06, 0x86, 0xbb, 0x28, 0xaf, 0x3c, 0x41, 0x4e, 0x01, 0x04, 0x0d,
	0xd8, 0x19, 0x94, 0xe7, 0x53, 0x9e, 0x27, 0xf6, 0xc5, 0xdb, 0xb2, 0xff, 0xd5, 0x6f, 0xf7, 0x3c,
	0xf1, 0x1a, 0x40, 0xd4, 0x35, 0xc4, 0xcd, 0x29, 0x73, 0x4a, 0x09, 0xf0, 0x00, 0x3d, 0xfc, 0xdb,
	0x0d, 0xe9, 0x27, 0x83, 0x01, 0x48, 0x12, 0xb0, 0x90, 0x29, 0xd2, 0xff, 0xa8, 0x20, 0x2e, 0x2f,
	0xa4, 0x5d, 0xaa, 0x97, 0xd4, 0x1e, 0xed, 0x45, 0x6a, 0xbb, 0xf6, 0x96, 0x06, 0x09, 0xb8, 0x0f,
	0xc4, 0x45, 0xcf, 0x8d, 0x94, 0x64, 0x5f, 0x73, 0x34, 0x34, 0x05, 0x8e, 0x51, 0xd5, 0xe3, 0x61,
	0xc8, 0x23, 0x32, 0x54, 0x4a, 0x90, 0x94, 0xc2, 0xe3, 0x01, 0xe1, 0x42, 0x97, 0xc7, 0xe5, 0xc5,
	0xb4, 0x45, 0xed, 0x06, 0x23, 0x6d, 0xa5, 0x44, 0x37, 0x83, 0x76, 0x0c, 0xd2, 0x5d, 0x35, 0xbc,
	0x57, 0xa4, 0x2a, 0xdf, 0x2d, 0x94, 0xbb, 0xe8, 0x1d, 0x3f, 0x42, 0xa5, 0xc9, 0xdd, 0x69, 0x0d,
	0x7d, 0x88, 0xb3, 0xe9, 0x15, 0x27, 0xf1, 0x6e, 0x1a, 0xc6, 0x2f, 0x51, 0x61, 0x5a, 0xaa, 0xc7,
	0x36, 0xeb, 0xcc, 0xf2, 0x13, 0x98, 0x9e, 0x1a, 0x3e, 0x40, 0x78, 0xca, 0xc3, 0x22, 0x05, 0xf2,
	0x8c, 0x06, 0xd9, 0xdc, 0x6e, 0xe4, 0x5a, 0x9e, 0x40, 0xf7, 0x32, 0x64, 0xe5, 0xdb, 0x3c, 0x5a,
	0xb9, 0xc2, 0x2b, 0x6e, 0xa0, 0x1c, 0x3b, 0x09, 0x60, 0xb2, 0x61, 0xd6, 0x6c, 0x1d, 0x96, 0x34,
	0x68, 0xbc, 0x5e, 0x8f, 0xd1, 0xb2, 0xde, 0xf3, 0x21, 0xd0, 0x13, 0x90, 0x31, 0xf1, 0x78, 0x12,
	0x99, 0x55, 0xcd, 0xbb, 0xc5, 0x90, 0x8e, 0xda, 0x26, 0xde, 0xd4, 0x61, 0xdc, 0x41, 0x2b, 0xba,
	0x36, 0x56, 0x12, 0x68, 0x48, 0xc6, 0x7f, 0xde, 0xcc, 0xc6, 0x42, 0x3a, 0x3a, 0x4c, 0xa1, 0xe3,
	0x04, 0xfe, 0x64, 0xa1, 0xf5, 0x71, 0xe7, 0x73, 0xa6, 0x86, 0x24, 0x89, 0xf4, 0xb7, 0xc7, 0x25,
	0xc4, 0x84, 0x9a, 0x3f, 0x4d, 0x2f, 0x62, 0xa1, 0xd6, 0xf9, 0xff, 0x2d, 0xb1, 0x33, 0xed, 0xc7,
	0x4c, 0x0d, 0x8f, 0xa6, 0xbc, 0xf5, 0x14, 0xe6, 0x56, 0x87, 0xd7, 0x64, 0x37, 0x0f, 0x50, 0xf5,
	0x3a, 0x34, 0xbe, 0x8b, 0x16, 0xeb, 0xfb, 0xfb, 0x9d, 0xe3, 0xd2, 0x2d, 0x8c, 0x51, 0xc1, 0x6d,
	0xbd, 0x6a, 0x35, 0x7b, 0xc4, 0x6d, 0xbd, 0x39, 0x6a, 0x1d, 0xf6, 0x4a, 0x16, 0x2e, 0xa2, 0xa5,
	0x5d, 0xb7, 0xd3, 0x25, 0xed, 0x56, 0x7d, 0xb7, 0xe5, 0x96, 0xe6, 0x1a, 0x2f, 0xbe, 0xfe, 0x5e,
	0xb0, 0xbe, 0xfc, 0x5a, 0xb3, 0xde, 0x3d, 0x9b, 0xed, 0x8d, 0x14, 0xa7, 0x7e, 0xf6, 0x4e, 0xf6,
	0x6f, 0xa7, 0x17, 0xba, 0xfd, 0x27, 0x00, 0x00, 0xff, 0xff, 0xde, 0x76, 0x3d, 0x3c, 0x5e, 0x05,
	0x00, 0x00,
}

func (this *ConnectionConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConnectionConfig)
	if !ok {
		that2, ok := that.(ConnectionConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MaxRequestsPerConnection != that1.MaxRequestsPerConnection {
		return false
	}
	if this.ConnectTimeout != nil && that1.ConnectTimeout != nil {
		if *this.ConnectTimeout != *that1.ConnectTimeout {
			return false
		}
	} else if this.ConnectTimeout != nil {
		return false
	} else if that1.ConnectTimeout != nil {
		return false
	}
	if !this.TcpKeepalive.Equal(that1.TcpKeepalive) {
		return false
	}
	if !this.PerConnectionBufferLimitBytes.Equal(that1.PerConnectionBufferLimitBytes) {
		return false
	}
	if !this.CommonHttpProtocolOptions.Equal(that1.CommonHttpProtocolOptions) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *ConnectionConfig_TcpKeepAlive) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConnectionConfig_TcpKeepAlive)
	if !ok {
		that2, ok := that.(ConnectionConfig_TcpKeepAlive)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.KeepaliveProbes != that1.KeepaliveProbes {
		return false
	}
	if this.KeepaliveTime != nil && that1.KeepaliveTime != nil {
		if *this.KeepaliveTime != *that1.KeepaliveTime {
			return false
		}
	} else if this.KeepaliveTime != nil {
		return false
	} else if that1.KeepaliveTime != nil {
		return false
	}
	if this.KeepaliveInterval != nil && that1.KeepaliveInterval != nil {
		if *this.KeepaliveInterval != *that1.KeepaliveInterval {
			return false
		}
	} else if this.KeepaliveInterval != nil {
		return false
	} else if that1.KeepaliveInterval != nil {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *ConnectionConfig_HttpProtocolOptions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConnectionConfig_HttpProtocolOptions)
	if !ok {
		that2, ok := that.(ConnectionConfig_HttpProtocolOptions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.IdleTimeout != nil && that1.IdleTimeout != nil {
		if *this.IdleTimeout != *that1.IdleTimeout {
			return false
		}
	} else if this.IdleTimeout != nil {
		return false
	} else if that1.IdleTimeout != nil {
		return false
	}
	if this.MaxHeadersCount != that1.MaxHeadersCount {
		return false
	}
	if this.MaxStreamDuration != nil && that1.MaxStreamDuration != nil {
		if *this.MaxStreamDuration != *that1.MaxStreamDuration {
			return false
		}
	} else if this.MaxStreamDuration != nil {
		return false
	} else if that1.MaxStreamDuration != nil {
		return false
	}
	if this.HeadersWithUnderscoresAction != that1.HeadersWithUnderscoresAction {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
